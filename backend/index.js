import dotenv from 'dotenv'; 
dotenv.config();
import express from 'express';
import mysql from 'mysql2';
import cors from 'cors';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { dbConfig, serverConfig, corsConfig } from './config/config.js'; // Import database configuration
import rateLimit from 'express-rate-limit';

// CRUD operations for user profiles(Create, Read, Update, Delete)
// Secure password storage with bcrypt
// User authentication with JWT
// Environment variables for sensitive data
// Input validation and sanitization
// Error handling and logging
const app = express();
const dbconn = mysql.createConnection(dbConfig);
const PORT = serverConfig.port || 8800; // Default to 8800 if not set
app.use(cors({ origin: 'http://localhost:3000', methods: ['GET','POST','PUT','DELETE'], allowedHeaders: ['Content-Type','Authorization'] , credentials: true })); // Adjust origin as needed for production
app.use(express.json());

// Connect to the MySQL database
async function connectToDatabase(retries = 5, delay = 2000) {
	for (let attempt = 1; attempt <= retries; attempt++) {
		try {
			await dbconn.connect();
			console.log('DB MySQL connected and ready');
			return;
		} catch (err) {
			console.error(`DB connection attempt ${attempt} failed:`, err);
			if (attempt < retries) {
				console.log(`Retrying in ${delay / 1000} seconds...`);
				await new Promise(res => setTimeout(res, delay));
			}
		}
	}
	console.error('All DB connection attempts failed. Exiting.');
	process.exit(1);
}
connectToDatabase();

// Rate limiter for user profile creation endpoint
const createUserLimiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 10, // limit each IP to 10 requests per windowMs
	message: { error: 'Too many accounts created from this IP, please try again after 15 minutes.' }
});

// Rate limiter for user profile table GET endpoint
const getUserProfileLimiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 100, // limit each IP to 100 requests per windowMs
	message: { error: 'Too many requests from this IP, please try again after 15 minutes.' }
});

// Rate limiter for login endpoint
const loginLimiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 10, // limit each IP to 10 login requests per windowMs
	message: { error: 'Too many login attempts from this IP, please try again after 15 minutes.' }
});

// Test endpoint to verify server is running
app.get('/', (req, res) => {
	res.json('hello from the express backend!');
});
// Health-check route
app.get('/ping', (req, res) => {
  console.log('✅ /ping route hit');
  res.status(200).json({ message: 'pong' });
});

// Endpoint to fetch all user profiles
app.get('/api/userprofile', getUserProfileLimiter, (req, res) => {
	const getProfileQuery = 'SELECT * FROM profiledata.userprofile';
	dbconn.query(getProfileQuery, (err, data) => {
		if (err) return res.json({ error: err.message }); // Handle error and send response
		return res.json(data);
	});
});

// TODO: remake create user endpoint with hashed passwords and validation
// Endpoint to create a new user profile (Create)
app.post('/api/create', createUserLimiter, async (req, res) => {
	// method to create a new user profile using Node.js, Express, bcrypt, and MySQL
	// user profile will contain 
	// autogenerated idusers(primary key),
	// [varchar(45) username, 
	// varchar(255) password(hashed){note: user will enter plain text, so authentication must hash the plaintext and compare hashes}, 
	// nullable varchar(45) email, 
	// enum role{default 'user','photographer','videographer','musician','artist','admin'}
	// timestamp created,
	// ]
	const { username, password, email, role } = req.body;

	// Basic input validation
	if (!username || !password) {
		return res.status(400).json({ error: 'Username and password are required.' });
	}
	// Validate username: only allow alphanumeric and underscores, 3-30 chars
	const usernameRegex = /^[a-zA-Z0-9_]{3,30}$/;
	if (!usernameRegex.test(username)) {
		return res.status(400).json({ error: 'Invalid username format. Only alphanumeric characters and underscores are allowed, 3-30 characters long.' });
	}
	// Validate password: minimum 2 characters for testing, should be 6+ in production
	if (password.length < 2) {
		return res.status(400).json({ error: 'Password must be at least 6 characters long.' });
	}
	// Hash the password before storing it
	try {
		const hashedPassword = await hashPassword(password);
		const createUserQuery = 'INSERT INTO profiledata.userprofile (username, userpassword, email, role) VALUES (?, ?, ?, ?)';
		const values = [username, hashedPassword, email || null, role || 'user'];
		dbconn.query(createUserQuery, values, (err, data) => {
			if (err) {
				if (err.code === 'ER_DUP_ENTRY') {
					return res.status(409).json({ error: 'Username already exists.' });
				}
				return res.status(500).json({ error: err.message });
			} else {
				return res.status(201).json({ message: 'User profile created successfully!', userId: data.insertId });
			}

		});
	} catch (err) {
		return res.status(500).json({ error: 'Error hashing password' });
	}
});



//TODO: Login endpoint should: validate input, check user existence w/ database table, compare hashed passwords w/ db, generate JWT, handle errors and update global state of app to logged in user and load user profile data
// Verify user credentials async using authenticateUser method and issue JWT (Login), with rate limiting to prevent brute-force attacks
app.post('/login', loginLimiter, async (req, res) => {
	console.log('✅ /login route hit');
	// method to authenticate a user using Node.js, Express, bcrypt, JWT, and MySQL
	const { username, password } = req.body;
	if (!username || !password) {
		return res.status(400).json({ error: 'Username and password are required.' });
	}
	try {
		const result = await authenticateUser(username, password);
		return res.json(result); // Return user info and token
	} catch (err) {
		return res.status(err.status || 500).json({ error: err.error || 'Internal server error' });
	}
});

// Endpoint to update user profile (Update)
app.put('/userprofile/:id', (req, res) => {
	// Update user profile table(email, role) located by id 
	const userId = req.params.id;
	const { username, email, role } = req.body;
	// table columns:[varchar(45) username, 
	// varchar(255) password(hashed){note: user will enter plain text, so authentication must hash the plaintext and compare hashes}, 
	// nullable varchar(45) email, 
	// enum role{default 'user','photographer','videographer','musician','technician','admin'}
	// timestamp created]
	const updateQuery = 'UPDATE profiledata.userprofile SET username = ?, email = ?, role = ? WHERE idusers = ?';
	const values = [username, email, role, userId];
	dbconn.query(updateQuery, values, (err, data) => {
		if (err) return res.status(500).json({ error: err.message });
		return res.json({ message: 'User profile updated successfully!' });
	});
});

// Endpoint to delete user profile (Delete)
app.delete('/userprofile/:id', (req, res) => {
	const userId = req.params.id;
	const deleteQuery = 'DELETE FROM profiledata.userprofile WHERE idusers = ?';
	dbconn.query(deleteQuery, [userId], (err, data) => {
		if (err) return res.status(500).json({ error: err.message });
		return res.json({ message: 'User profile deleted successfully!' });
	});
});

// Start the server + test DB conection
;(async () => {
	try {
		const conn = await mysql.createConnection(dbConfig);
		console.log('MySQL connected');
		await conn.end();

		const { port } = serverConfig;
		app.listen(port, () => {
			console.log(`Server listening on http://localhost:${port}`);
		});
	} catch (err) {
		console.error('Startup error:', err);
		process.exit(1);
	}
})();

// TODO: fix JWT authentication middleware to protect routes
// if (authHeader) {
// 	const token = authHeader.split(' ')[1];
// 	jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
// 		if (err) {
// 			return res.status(403).json({ error: 'Invalid token' });
// 		}
// 		req.user = user;
// 		next();
// 	});
// } else {
// 	res.status(401).json({ error: 'Authorization header missing' });
// }

// Function to handle user logout
const handleLogout = (dispatch, navigate) => {
	// Clear user data and token from local storage and cookies
	localStorage.removeItem('token');
	Cookies.remove('token');
	Cookies.remove('username');
	// Dispatch logout action to update Redux state
	dispatch(logout());
	// Redirect to login page after logout
	if (navigate) {
		navigate('/login');
	}
};

//This authentication function asynchronously verifies user credentials, compares hashed passwords, and generates a JWT for session management. It is called in the login endpoint to handle user authentication securely.
// Extracted authentication logic for maintainability
async function authenticateUser(username, password) {
	// Return a promise to handle async operations
	return new Promise((resolve, reject) => {
		const authenticateQuery = 'SELECT * FROM profiledata.userprofile WHERE username = ?';
		// Use parameterized query to prevent SQL injection
		dbconn.query(authenticateQuery, [username], async (err, results) => {
			if (err) return reject({ status: 500, error: 'Database query error' });
			if (results.length === 0) return reject({ status: 401, error: 'Invalid username or password' });
			const user = results[0];
			// Compare hashed passwords
			const isPasswordValid = await bcrypt.compare(password, user.userpassword);
			if (!isPasswordValid) return reject({ status: 401, error: 'Invalid username or password' });
			// Generate JWT
			const token = jwt.sign({ id: user.idusers, username: user.username, role: user.role }, process.env.JWT_SECRET, { expiresIn: '1h' });
			// Return user info and token
			resolve({ id: user.idusers, username: user.username, email: user.email, role: user.role, token });
		});
	},
); // Note: In a production environment, ensure to handle JWT secret securely and consider token expiration and refresh mechanisms.
}

async function hashPassword(plainTextPassword) {
	const saltRounds = 10;
	return await bcrypt.hash(plainTextPassword, saltRounds);
}

export { handleLogout };